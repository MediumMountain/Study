# MQTT（Message Queuing Telemetry Transport）


- リソースに制約のあるデバイスや低帯域幅、高遅延、または信頼性の低いネットワーク向けに設計された、軽量でパブリッシュ・サブスクライブに基づくメッセージングプロトコル

- Publish/Subscribeパターンのメッセージングにより、非同期に1対多の通信をすることが可能

- 組み込みデバイス、センサー、産業用PLCなどのIoTおよび産業用IoT（IIoT）デバイス間のメッセージングとデータ交換など、メモリの制約が厳しかったり、ネットワーク帯域幅が限られているような環境での利用に適している。


# MQTTはIoTに最適なプロトコル理由は？
- MQTTは、IoTシステムの特定の要求に合わせた機能と性能により、最適なIoTプロトコルの1つとしてよく使用されています。主な理由としては、以下のようなものがあります：

## 軽量：
- IoT機器は、処理能力、メモリ、エネルギー消費量に制約があることが多い。
- MQTTはオーバーヘッドが少なく、パケットサイズも小さいため、これらの機器に最適で、リソースの消費も少なく、限られた機能でも効率的な通信が可能です。


## 信頼性が高い：
- IoTネットワークでは、高遅延や不安定な接続が発生することがあります。
- MQTTは、さまざまなQoSレベル、セッション認識、持続的な接続をサポートしており、厳しい条件下でも信頼性の高いメッセージ配信を実現するため、IoTアプリケーションに適しています。

## セキュアな通信を実現します：
- IoTネットワークでは、機密データを送信することが多いため、セキュリティは極めて重要です。
- MQTTはTLS（Transport Layer Security）とSSL（Secure Sockets Layer）の暗号化をサポートし、伝送中のデータのセキュリティを確保できます。さらに、ユーザー名/パスワード認証やクライアント証明書による認証のメカニズムを提供し、ネットワークとそのリソースへのアクセスを保護します。

## 双方向性：
- MQTTのパブリッシュ・サブスクライブモデルは、デバイス間のシームレスな双方向通信を可能にしています。
- クライアントは、Topicへのメッセージのパプリッシュと、特定のTopicに関するメッセージの受信の両方を行うことができ、デバイス間を直接結合することなく、多様なIoTエコシステムにおいて効果的なデータ交換を可能にします。
- また、このモデルは、新しいデバイスの統合を簡素化し、容易なスケーラビリティを保証します。

## 連続性、ステートフル・セッション：
- MQTT では、クライアントがブローカーとのステートフルなセッションを維持できるため、切断後でもサブスクリプションや未配信のメッセージをシステムが記憶することができます。
- また、クライアントは接続中にキープアライブ間隔を指定することができ、これによりブローカーは定期的に接続状態を確認するよう促されます。
- 接続が切れた場合、ブローカーは未配信のメッセージを保存し（QoSレベルによる）、クライアントが再接続したときに配信を試みます。
- この機能により、信頼性の高い通信を実現し、断続的な接続によるデータ消失のリスクを低減します。


## 大規模なIoTデバイスへの対応：
- IoTシステムには多数のデバイスが含まれることが多く、大規模なデプロイメントに対応するプロトコルが必要です。
- MQTTの軽量性、低帯域幅消費、リソースの効率的な使用は、大規模なIoTアプリケーションに適しています。
- MQTTは、パブリッシュ・サブスクライブ・パターンにより、送信者と受信者を分離し、ネットワークトラフィックとリソース使用量を削減するため、効果的に拡張することができます。
- さらに、このプロトコルはさまざまなQoSレベルをサポートしているため、アプリケーションの要件に基づいてメッセージ配信をカスタマイズすることができ、さまざまなシナリオで最適なパフォーマンスを確保することができます。

## 多プログラミング言語に対応：
- IoTシステムには、多くのプログラミング言語を使用して開発されたデバイスやアプリケーションが含まれることがよくあります。
- MQTTの幅広い言語サポートにより、複数のプラットフォームやテクノロジーとの統合が容易になり、多様なIoTエコシステムにおいてシームレスな通信と相互運用性が促進されます。
- PHP、Node.js、Python、Golang、Node.js、その他のプログラミング言語でのMQTTの使用方法については、MQTT Client Programmingのブログシリーズをご覧下さい。



# MQTTの仕組みは？
MQTTの仕組みを理解するためには、まずMQTT クライアント、MQTT Broker、Publish-Subscribeモード、Topic、QoSの概念をマスターする必要があります：

## MQTTクライアント
- MQTTクライアント・ライブラリを実行するアプリケーションやデバイスは、すべてMQTTクライアントとなります。
- 例えば、MQTTを利用するインスタントメッセージングアプリはクライアント、MQTTを利用してデータを報告する各種センサーはクライアント、各種MQTTテストツールもクライアントとなります。

## MQTTブローカー
- MQTT ブローカーは、クライアントの接続、切断、サブスクリプション、およびアンサブスクリプションの要求、およびメッセージのルーティングを処理する。
- 強力なMQTTブローカーは、大量の接続と100万レベルのメッセージスループットをサポートし、IoTサービスプロバイダーがビジネスに集中し、信頼性の高いMQTTアプリケーションを迅速に作成できるようにします。

MQTTブローカーの詳細については、ブログ「The Ultimate Guide to MQTT Broker Comparison in 2023」をご確認ください。

## パブリッシュ・サブスクライブ・パターン

パブリッシュ・サブスクライブ・パターンは、メッセージを送信するクライアント（パブリッシャー）とメッセージを受信するクライアント（サブスクライバー）を分離するという点で、クライアント・サーバー・パターンとは異なる。パブリッシャーとサブスクライバーは直接接続する必要がなく、MQTT Brokerがすべてのメッセージのルーティングと配布を担当します。

次の図は、MQTTのパブリッシュ/サブスクライブ処理を示しています。温度センサーがクライアントとしてMQTTサーバーに接続し、温度データをTopic（例： 「Temperature」 ）にパブリッシュすると、サーバーはメッセージを受信して 「Temperature」 Topicをサブスクライブしているクライアントに転送する。


## Topic

MQTTプロトコルは、Topicに基づいてメッセージをルーティングします。Topicはスラッシュ / で階層を区別し、それはURLパスに似ています：


MQTT Topicは、以下のワイルドカードをサポートしています： + と # です。

```
+ ： a/+ が a/x や a/y にマッチするような、1レベルのワイルドカードを示す。
# ： a/# と a/x 、 a/b/c/d のマッチングのように、複数レベルのワイルドカードを示す。
```

MQTT Topicの詳細については、ブログ「Understanding MQTT Topics & Wildcards by Case」をご確認ください。

## サービス品質（QoS）

- MQTTは3種類のQoSを提供し、異なるネットワーク環境でのメッセージングの信頼性を保証します。

### QoS 0：
- メッセージは最大1回配信される。クライアントが現在利用できない場合、このメッセージは失われる。

### QoS 1：
- 少なくとも1回はメッセージが届く。

### QoS 2：
- メッセージは確保して1回のみ届く。


MQTT QoSの詳細については、ブログ「Introduction to MQTT QoS (Quality of Service)」をご確認ください。


Retained Messages
Publish/SubscribeパターンはSubscribeを開始するまでにPublishされたメッセージは届きません。なので、状況によっては（Publishのインターバルが長い場合など）、Subscribe開始後、無応答のような状況が発生してしまいます。これを避けるために、Retained Messagesを使用します。すると、ブローカーは最後にPublishされたメッセージを保持して、新しいSubscribeを受けるとそのメッセージを通知します

MQTTプロトコルフォーマットのフラグでは、PublishでRETAINというフラグがあるので、これを設定することでRetained Messagesを使用することが可能です

また、ブローカーは、1つのトピックにつき1つのRetained Messagesのみを保存します

LWT（Last Will and Testament）
パブリッシャーは、MQTTブローカーと接続したときに Last Will and Testament（遺言） という情報を追加することができます。意図しない原因でパブリッシャーと通信できなくなった場合に、ブローカーはLWTに指定されたメッセージをサブスクライバーへ送信します。サブスクライバーはこのメッセージを受信することで、対象のパブリッシャーが意図しない原因で停止していることがわかります。

クライアントが正しい DISCONNECT メッセージで正しく切断された場合、ブローカーは保存された LWT メッセージを破棄します

Keep Alive
例えばプログラムのバグなどにより、MQTTに利用するコネクションは生きているが、実際の通信ができないような状態（TCPのハーフコネクション問題）に陥ることがあります。この場合、ハーフコネクションの相手がデータを送り続けても、相手側にメッセージが届くことはありません。この問題に対応するため、MQTTプロトコルでは、ハーフコネクションを判断し、該当するコネクションを切断するKeep Aliveという仕組みを提供しています

Keep Aliveがハーフコネクションを発見する仕組み
MQTTクライアントとMQTTブローカーの接続が確立された後、クライアントは送信する2つのMQTTプロトコルパケットの間隔がKeep Alive値を超えないようにする必要があります。つまり、Keep Aliveの値を超えるとハーフコネクションが発生していると判断します

Keep Alive値を超えてしまうとコネクションが切断されてしまうため、通常時はメッセージの代わりにPINGREQプロトコルパケットを送信します

※ ハーフコネクションだと判断され、コネクションが切断された場合、Last Will and Testamentメッセージを送信します（クライアントが LWT を指定していた場合）

Keep Aliveの設定方法
MQTTクライアントがMQTTブローカーとの接続を作成する際に、Keep Aliveフィールドに0以外の値を設定することで、通信当事者間でKeep Aliveを有効にすることができます。Keep Aliveは0～65535の整数で設定します


## MQTTワークフロー
- MQTTの基本的な構成要素を理解したところで、一般的なワークフローを確認してみましょう：

クライアントは、TCP/IPを使用してブローカーへの接続を開始し、オプションでTLS/SSL暗号化により安全な通信を行います。クライアントは認証情報を提供し、クリーンまたは永続的なセッションを指定します。
クライアントは、特定のTopicにメッセージを公開するか、Topicにサブスクライブしてメッセージを受信します。パブリッシング・クライアントはブローカーにメッセージを送信し、サブスクライブ・クライアントは特定のTopicに関するメッセージの受信に関心を示す。
ブローカーは公開されたメッセージを受信し、関連するTopicをサブスクライブしているすべてのクライアントに転送する。指定されたサービス品質（QoS）レベルに従って信頼性の高いメッセージ配信を保証し、セッションタイプに基づいて切断されたクライアントのメッセージストレージを管理する。







## REFERENCE

https://www.emqx.com/ja/blog/the-easiest-guide-to-getting-started-with-mqtt
https://qiita.com/kbys-fumi/items/3ebb31a94fd3f9cc0b7a